/**
 * Math Quest Laboratory - Sistema de Pistas Pedag√≥gicas
 * Sistema inteligente de ayuda adaptativa para el aprendizaje matem√°tico
 * 
 * Desarrollado por: Profe Marlon Arcila
 * Instituci√≥n: Colegio Mayor de Antioquia
 * Versi√≥n: 1.0.0
 * 
 * Funcionalidad:
 * üÜï Componente completamente nuevo (espec√≠fico del laboratorio)
 * üß† Pistas adaptatitvas seg√∫n el error del estudiante
 * üìö Enfoque pedag√≥gico constructivista
 * üéØ Gu√≠a progresiva sin dar respuestas directas
 */

// =====================================================
// CLASE PRINCIPAL - SISTEMA DE HINTS
// =====================================================

/**
 * Sistema de pistas pedag√≥gicas adaptativas
 * Proporciona ayuda contextual e inteligente sin comprometer el aprendizaje
 */
class HintSystem {
    /**
     * Constructor del sistema de hints
     * @param {Object} pedagogicalConfig - Configuraci√≥n pedag√≥gica
     */
    constructor(pedagogicalConfig = {}) {
        console.log('üí° Inicializando HintSystem...');
        
        // Configuraci√≥n pedag√≥gica
        this.config = {
            maxHints: pedagogicalConfig.maxHints || 3,
            adaptiveHints: pedagogicalConfig.adaptiveHints || true,
            contextualFeedback: pedagogicalConfig.contextualFeedback || true,
            errorPatterns: pedagogicalConfig.errorPatterns || true,
            feedbackLevel: pedagogicalConfig.feedbackLevel || 'constructive'
        };
        
        // Estado del sistema
        this.state = {
            hintsUsed: 0,
            currentProblemHints: [],
            errorHistory: [],
            adaptiveLevel: 1, // Nivel de ayuda adaptativo
            studentProfile: this.createStudentProfile()
        };
        
        // Biblioteca de pistas por tema
        this.hintLibrary = this.initializeHintLibrary();
        
        // Patrones de error comunes
        this.errorPatterns = this.initializeErrorPatterns();
        
        console.log('‚úÖ HintSystem inicializado');
    }

    // =====================================================
    // INICIALIZACI√ìN Y CONFIGURACI√ìN
    // =====================================================

    /**
     * Crear perfil del estudiante para personalizaci√≥n
     * @returns {Object} Perfil inicial del estudiante
     */
    createStudentProfile() {
        return {
            preferredHintType: 'conceptual', // conceptual, visual, procedural
            errorTendencies: [], // Patrones de error identificados
            learningSpeed: 'normal', // slow, normal, fast
            confidenceLevel: 'medium', // low, medium, high
            lastSuccessfulStrategy: null
        };
    }

    /**
     * Inicializar biblioteca de pistas por tema matem√°tico
     * @returns {Object} Biblioteca organizada de pistas
     */
    initializeHintLibrary() {
        return {
            // Suma y resta de enteros
            suma_enteros_negativos: {
                conceptual: [
                    "Record√° que sumar un n√∫mero negativo es lo mismo que restar ese n√∫mero",
                    "Los n√∫meros negativos representan direcciones opuestas en la recta num√©rica",
                    "Pens√° en los n√∫meros negativos como 'deudas' que se restan de lo que ten√©s"
                ],
                procedural: [
                    "Para sumar un negativo: 100 + (-15) = 100 - 15",
                    "Cambi√° el signo: + (-15) se convierte en - 15",
                    "Oper√° de izquierda a derecha, paso a paso"
                ],
                visual: [
                    "Imagin√° una recta num√©rica: empez√°s en 100 y te mov√©s 15 posiciones hacia la izquierda",
                    "Visualiz√° una balanza: agregar peso negativo es como quitar peso positivo",
                    "Pens√° en un term√≥metro: la temperatura baja cuando agreg√°s 'fr√≠o'"
                ]
            },
            
            // Valor absoluto
            valor_absoluto: {
                conceptual: [
                    "El valor absoluto |x| siempre es positivo - representa la distancia al cero",
                    "El valor absoluto elimina el signo, solo te queda la magnitud",
                    "Es como preguntarse: '¬øqu√© tan lejos est√° este n√∫mero del cero?'"
                ],
                procedural: [
                    "Para |-25|: elimin√° el signo negativo, queda 25",
                    "El valor absoluto de cualquier n√∫mero es su versi√≥n positiva",
                    "|-25| = 25, |25| = 25, ambos tienen la misma distancia al cero"
                ],
                visual: [
                    "Imagin√° una recta num√©rica: -25 y 25 est√°n a la misma distancia del 0",
                    "Es como medir con una regla: solo importa la distancia, no la direcci√≥n",
                    "Pens√° en kil√≥metros: 25 km al norte o al sur, siguen siendo 25 km"
                ]
            },
            
            // Coordenadas y movimiento
            recta_numerica: {
                conceptual: [
                    "En una recta num√©rica: derecha es positivo (+), izquierda es negativo (-)",
                    "Moverse a la derecha suma, moverse a la izquierda resta",
                    "Tu posici√≥n actual + el movimiento = nueva posici√≥n"
                ],
                procedural: [
                    "Desde -5, moverse 8 a la derecha: -5 + 8 = 3",
                    "Luego desde 3, moverse 3 a la izquierda: 3 + (-3) = 0",
                    "Sumar el movimiento con su signo correspondiente"
                ],
                visual: [
                    "Dibuj√° una l√≠nea horizontal con n√∫meros: ...-5,-4,-3,-2,-1,0,1,2,3...",
                    "Marc√° tu posici√≥n inicial y cont√° los pasos del movimiento",
                    "Pens√° en caminar por una calle numerada"
                ]
            },
            
            // Operaciones secuenciales
            operaciones_secuenciales: {
                conceptual: [
                    "Resolv√© una operaci√≥n a la vez, en el orden que aparecen",
                    "El resultado de cada paso se convierte en el punto de partida del siguiente",
                    "Manten√© el orden: primero suma/resta de izquierda a derecha"
                ],
                procedural: [
                    "Paso 1: resolv√© la primera operaci√≥n",
                    "Paso 2: us√° ese resultado para la siguiente operaci√≥n",
                    "Paso 3: continu√° hasta completar toda la secuencia"
                ],
                visual: [
                    "Imagin√° una cadena de transformaciones, como una l√≠nea de producci√≥n",
                    "Cada operaci√≥n es una estaci√≥n que modifica el resultado anterior",
                    "Pens√° en un GPS que recalcula la ruta en cada intersecci√≥n"
                ]
            }
        };
    }

    /**
     * Inicializar patrones de error comunes y sus respuestas
     * @returns {Object} Patrones de error y feedback
     */
    initializeErrorPatterns() {
        return {
            sign_error: {
                pattern: /ignora.*negativo|olvida.*signo|suma.*positivo/i,
                feedback: "üîç Prest√° atenci√≥n a los signos. Los n√∫meros negativos son importantes en el c√°lculo.",
                remediation: "Record√°: +(-15) significa sumar un negativo, que es lo mismo que restar 15",
                hintType: "conceptual"
            },
            
            order_operations: {
                pattern: /orden.*incorrecto|secuencia.*errada/i,
                feedback: "‚ö° Excelente inicio. Ahora resolv√© paso a paso, de izquierda a derecha.",
                remediation: "Tom√° cada operaci√≥n por separado y us√° el resultado para la siguiente",
                hintType: "procedural"
            },
            
            calculation_error: {
                pattern: /aritm√©tica.*incorrecta|c√°lculo.*errado/i,
                feedback: "‚úÖ Tu m√©todo est√° perfecto. Revis√° solo las cuentas b√°sicas.",
                remediation: "Verific√° cada suma o resta individual: ¬ø100 - 15 = ?",
                hintType: "procedural"
            },
            
            conceptual_confusion: {
                pattern: /concepto.*confuso|no.*entiende/i,
                feedback: "üß† Tomemos un momento para entender el concepto detr√°s del problema.",
                remediation: "Pens√° en el significado real de la situaci√≥n antes de calcular",
                hintType: "conceptual"
            },
            
            magnitude_error: {
                pattern: /magnitud.*incorrecta|tama√±o.*errado/i,
                feedback: "üìè El procedimiento est√° bien, revis√° los n√∫meros que est√°s usando.",
                remediation: "Verific√° que est√©s usando los n√∫meros correctos del problema",
                hintType: "visual"
            }
        };
    }

    // =====================================================
    // GENERACI√ìN DE HINTS INTELIGENTES
    // =====================================================

    /**
     * Generar hint contextual e inteligente
     * @param {number} currentStep - Paso actual del problema
     * @param {Object} problem - Problema completo
     * @param {Array} errorHistory - Historial de errores del estudiante
     * @returns {Object} Hint generado
     */
    generateHint(currentStep, problem, errorHistory = []) {
        console.log(`üí° Generando hint para paso ${currentStep + 1}...`);
        
        if (!this.canProvideHint()) {
            return this.createErrorHint('No hay m√°s pistas disponibles para este problema');
        }

        // Analizar contexto del estudiante
        const context = this.analyzeStudentContext(currentStep, problem, errorHistory);
        
        // Seleccionar estrategia de hint
        const strategy = this.selectHintStrategy(context);
        
        // Generar hint espec√≠fico
        const hint = this.createContextualHint(currentStep, problem, strategy, context);
        
        // Registrar hint en el historial
        this.state.currentProblemHints.push(hint);
        this.state.hintsUsed++;
        
        // Actualizar perfil del estudiante
        this.updateStudentProfile(context, strategy);
        
        console.log(`üí° Hint nivel ${hint.level} generado: ${hint.type}`);
        return hint;
    }

    /**
     * Analizar contexto del estudiante para personalizar hint
     * @param {number} currentStep - Paso actual
     * @param {Object} problem - Problema completo
     * @param {Array} errorHistory - Errores previos
     * @returns {Object} Contexto analizado
     */
    analyzeStudentContext(currentStep, problem, errorHistory) {
        const recentErrors = errorHistory.slice(-3); // √öltimos 3 errores
        const step = problem.solution.steps[currentStep];
        
        return {
            currentStep: currentStep,
            stepType: this.classifyStepType(step),
            recentErrorPatterns: this.identifyErrorPatterns(recentErrors),
            difficultyLevel: problem.difficulty || 2,
            timeOnStep: this.estimateTimeOnStep(),
            studentStruggle: this.assessStruggleLevel(recentErrors),
            preferredLearningStyle: this.state.studentProfile.preferredHintType,
            hintLevel: this.determineHintLevel()
        };
    }

    /**
     * Clasificar tipo de paso matem√°tico
     * @param {Object} step - Paso actual
     * @returns {string} Tipo de paso
     */
    classifyStepType(step) {
        const operation = step.operation.toLowerCase();
        
        if (operation.includes('+') && operation.includes('-')) {
            return 'mixed_operations';
        } else if (operation.includes('(-')) {
            return 'negative_addition';
        } else if (operation.includes('|')) {
            return 'absolute_value';
        } else if (operation.includes('+')) {
            return 'addition';
        } else if (operation.includes('-')) {
            return 'subtraction';
        } else {
            return 'other';
        }
    }

    /**
     * Seleccionar estrategia de hint basada en contexto
     * @param {Object} context - Contexto del estudiante
     * @returns {string} Estrategia seleccionada
     */
    selectHintStrategy(context) {
        // Si es el primer hint, usar enfoque conceptual
        if (context.hintLevel === 1) {
            return 'conceptual_orientation';
        }
        
        // Si hay patrones de error espec√≠ficos, abordarlos
        if (context.recentErrorPatterns.length > 0) {
            return 'error_remediation';
        }
        
        // Si el estudiante lucha, dar m√°s orientaci√≥n
        if (context.studentStruggle === 'high') {
            return 'guided_procedure';
        }
        
        // Si es el tercer hint, ser m√°s expl√≠cito
        if (context.hintLevel === 3) {
            return 'explicit_guidance';
        }
        
        // Por defecto, orientaci√≥n procedimental
        return 'procedural_guidance';
    }

    /**
     * Crear hint contextual basado en estrategia
     * @param {number} currentStep - Paso actual
     * @param {Object} problem - Problema completo
     * @param {string} strategy - Estrategia seleccionada
     * @param {Object} context - Contexto del estudiante
     * @returns {Object} Hint creado
     */
    createContextualHint(currentStep, problem, strategy, context) {
        const step = problem.solution.steps[currentStep];
        const hintLevel = context.hintLevel;
        
        switch (strategy) {
            case 'conceptual_orientation':
                return this.createConceptualHint(step, context.stepType, hintLevel);
                
            case 'error_remediation':
                return this.createErrorRemediationHint(step, context.recentErrorPatterns, hintLevel);
                
            case 'guided_procedure':
                return this.createGuidedProcedureHint(step, hintLevel);
                
            case 'explicit_guidance':
                return this.createExplicitHint(step, hintLevel);
                
            case 'procedural_guidance':
            default:
                return this.createProceduralHint(step, hintLevel);
        }
    }

    // =====================================================
    // TIPOS ESPEC√çFICOS DE HINTS
    // =====================================================

    /**
     * Crear hint conceptual (nivel 1)
     * @param {Object} step - Paso actual
     * @param {string} stepType - Tipo de paso
     * @param {number} level - Nivel del hint
     * @returns {Object} Hint conceptual
     */
    createConceptualHint(step, stepType, level) {
        const library = this.hintLibrary[stepType] || this.hintLibrary.operaciones_secuenciales;
        const concepts = library.conceptual || [];
        
        // Seleccionar concepto apropiado
        const conceptIndex = Math.min(level - 1, concepts.length - 1);
        const message = concepts[conceptIndex] || "Record√° el concepto b√°sico de esta operaci√≥n";
        
        return {
            level: level,
            type: "conceptual",
            strategy: "conceptual_orientation",
            message: message,
            icon: "fas fa-info-circle",
            pedagogicalFocus: "concept_building"
        };
    }

    /**
     * Crear hint de remediaci√≥n de errores
     * @param {Object} step - Paso actual
     * @param {Array} errorPatterns - Patrones de error identificados
     * @param {number} level - Nivel del hint
     * @returns {Object} Hint de remediaci√≥n
     */
    createErrorRemediationHint(step, errorPatterns, level) {
        if (errorPatterns.length === 0) {
            return this.createProceduralHint(step, level);
        }
        
        const primaryError = errorPatterns[0];
        const errorInfo = this.errorPatterns[primaryError] || this.errorPatterns.calculation_error;
        
        return {
            level: level,
            type: "remediation",
            strategy: "error_remediation",
            message: errorInfo.remediation,
            icon: "fas fa-tools",
            pedagogicalFocus: "error_correction"
        };
    }

    /**
     * Crear hint procedimental (nivel 2)
     * @param {Object} step - Paso actual
     * @param {number} level - Nivel del hint
     * @returns {Object} Hint procedimental
     */
    createProceduralHint(step, level) {
        const operation = step.operation;
        const description = step.description;
        
        let message;
        
        // Personalizar mensaje seg√∫n la operaci√≥n
        if (operation.includes('(-')) {
            message = `Para ${description}: ¬øCu√°nto es ${operation}? Record√° que sumar un negativo es restar.`;
        } else {
            message = `Para ${description}: ¬øCu√°nto es ${operation}?`;
        }
        
        return {
            level: level,
            type: "procedural",
            strategy: "procedural_guidance",
            message: message,
            icon: "fas fa-compass",
            pedagogicalFocus: "step_guidance"
        };
    }

    /**
     * Crear hint de procedimiento guiado
     * @param {Object} step - Paso actual
     * @param {number} level - Nivel del hint
     * @returns {Object} Hint guiado
     */
    createGuidedProcedureHint(step, level) {
        const operation = step.operation;
        const result = step.result;
        
        // Descomponer la operaci√≥n para guiar paso a paso
        let guidance = this.decomposeOperation(operation);
        
        return {
            level: level,
            type: "guided",
            strategy: "guided_procedure",
            message: `Vamos paso a paso: ${guidance}`,
            icon: "fas fa-route",
            pedagogicalFocus: "guided_learning"
        };
    }

    /**
     * Crear hint expl√≠cito (nivel 3)
     * @param {Object} step - Paso actual
     * @param {number} level - Nivel del hint
     * @returns {Object} Hint expl√≠cito
     */
    createExplicitHint(step, level) {
        const operation = step.operation;
        const result = step.result;
        
        return {
            level: level,
            type: "explicit",
            strategy: "explicit_guidance",
            message: `${operation} = ${result}`,
            icon: "fas fa-equals",
            pedagogicalFocus: "explicit_solution"
        };
    }

    /**
     * Crear hint de error
     * @param {string} message - Mensaje de error
     * @returns {Object} Hint de error
     */
    createErrorHint(message) {
        return {
            level: 0,
            type: "error",
            strategy: "error_notification",
            message: message,
            icon: "fas fa-exclamation-triangle",
            pedagogicalFocus: "system_limitation"
        };
    }

    // =====================================================
    // AN√ÅLISIS Y ADAPTACI√ìN
    // =====================================================

    /**
     * Identificar patrones de error en el historial
     * @param {Array} errors - Errores recientes
     * @returns {Array} Patrones identificados
     */
    identifyErrorPatterns(errors) {
        const patterns = [];
        
        errors.forEach(error => {
            if (error.errorType) {
                patterns.push(error.errorType);
            }
        });
        
        // Identificar patrones m√°s frecuentes
        const patternCount = {};
        patterns.forEach(pattern => {
            patternCount[pattern] = (patternCount[pattern] || 0) + 1;
        });
        
        // Retornar patrones ordenados por frecuencia
        return Object.keys(patternCount).sort((a, b) => patternCount[b] - patternCount[a]);
    }

    /**
     * Evaluar nivel de dificultad del estudiante
     * @param {Array} recentErrors - Errores recientes
     * @returns {string} Nivel de dificultad
     */
    assessStruggleLevel(recentErrors) {
        if (recentErrors.length >= 3) {
            return 'high';
        } else if (recentErrors.length >= 2) {
            return 'medium';
        } else {
            return 'low';
        }
    }

    /**
     * Determinar nivel apropiado de hint
     * @returns {number} Nivel del hint (1-3)
     */
    determineHintLevel() {
        const usedInProblem = this.state.currentProblemHints.length;
        return Math.min(usedInProblem + 1, 3);
    }

    /**
     * Estimar tiempo que el estudiante lleva en este paso
     * @returns {number} Tiempo estimado en segundos
     */
    estimateTimeOnStep() {
        // Por ahora, implementaci√≥n b√°sica
        // En una versi√≥n m√°s avanzada, podr√≠a medir tiempo real
        return 30; // 30 segundos por defecto
    }

    /**
     * Descomponer operaci√≥n matem√°tica para gu√≠a paso a paso
     * @param {string} operation - Operaci√≥n a descomponer
     * @returns {string} Gu√≠a descompuesta
     */
    decomposeOperation(operation) {
        // Analizar la operaci√≥n y proporcionar gu√≠a
        if (operation.includes('(-')) {
            const parts = operation.split('+');
            if (parts.length === 2) {
                const base = parts[0].trim();
                const negative = parts[1].trim();
                return `${base} m√°s ${negative} es lo mismo que ${base} ${negative.replace('(-', '- ').replace(')', '')}`;
            }
        }
        
        return `Calcul√° ${operation} paso a paso`;
    }

    /**
     * Actualizar perfil del estudiante basado en la interacci√≥n
     * @param {Object} context - Contexto de la interacci√≥n
     * @param {string} strategy - Estrategia utilizada
     */
    updateStudentProfile(context, strategy) {
        // Actualizar preferencias de tipo de hint
        if (context.hintLevel === 1) {
            // Primer hint, registrar estrategia inicial
            this.state.studentProfile.lastSuccessfulStrategy = strategy;
        }
        
        // Registrar tendencias de error
        if (context.recentErrorPatterns.length > 0) {
            context.recentErrorPatterns.forEach(pattern => {
                if (!this.state.studentProfile.errorTendencies.includes(pattern)) {
                    this.state.studentProfile.errorTendencies.push(pattern);
                }
            });
        }
        
        // Ajustar nivel de confianza basado en la necesidad de hints
        if (this.state.hintsUsed === 0) {
            this.state.studentProfile.confidenceLevel = 'high';
        } else if (this.state.hintsUsed <= 1) {
            this.state.studentProfile.confidenceLevel = 'medium';
        } else {
            this.state.studentProfile.confidenceLevel = 'low';
        }
    }

    // =====================================================
    // GESTI√ìN DE ESTADO
    // =====================================================

    /**
     * Verificar si se pueden proporcionar m√°s hints
     * @returns {boolean} Si se pueden proporcionar hints
     */
    canProvideHint() {
        return this.state.hintsUsed < this.config.maxHints;
    }

    /**
     * Obtener n√∫mero de hints usados
     * @returns {number} Hints usados
     */
    getHintsUsed() {
        return this.state.hintsUsed;
    }

    /**
     * Obtener hints restantes
     * @returns {number} Hints restantes
     */
    getRemainingHints() {
        return Math.max(0, this.config.maxHints - this.state.hintsUsed);
    }

    /**
     * Obtener estad√≠sticas del sistema de hints
     * @returns {Object} Estad√≠sticas
     */
    getHintStats() {
        return {
            hintsUsed: this.state.hintsUsed,
            maxHints: this.config.maxHints,
            hintsRemaining: this.getRemainingHints(),
            currentProblemHints: this.state.currentProblemHints.length,
            adaptiveLevel: this.state.adaptiveLevel,
            studentProfile: { ...this.state.studentProfile }
        };
    }

    /**
     * Resetear sistema para nuevo problema
     */
    reset() {
        console.log('üîÑ Reseteando HintSystem...');
        
        this.state.hintsUsed = 0;
        this.state.currentProblemHints = [];
        this.state.errorHistory = [];
        
        // Mantener perfil del estudiante para adaptaci√≥n continua
        // NO resetear this.state.studentProfile
        
        console.log('‚úÖ HintSystem reseteado para nuevo problema');
    }

    /**
     * Reset completo del sistema (incluyendo perfil del estudiante)
     */
    fullReset() {
        console.log('üîÑ Reset completo del HintSystem...');
        
        this.state = {
            hintsUsed: 0,
            currentProblemHints: [],
            errorHistory: [],
            adaptiveLevel: 1,
            studentProfile: this.createStudentProfile()
        };
        
        console.log('‚úÖ HintSystem completamente reseteado');
    }

    // =====================================================
    // M√âTODOS DE DEBUG Y TESTING
    // =====================================================

    /**
     * Obtener informaci√≥n de debug del sistema
     * @returns {Object} Informaci√≥n de debug
     */
    getDebugInfo() {
        return {
            config: { ...this.config },
            state: { ...this.state },
            hintLibraryKeys: Object.keys(this.hintLibrary),
            errorPatternKeys: Object.keys(this.errorPatterns),
            isReady: this.canProvideHint()
        };
    }

    /**
     * Simular generaci√≥n de hint para testing
     * @param {string} stepType - Tipo de paso a simular
     * @param {number} hintLevel - Nivel del hint
     * @returns {Object} Hint simulado
     */
    simulateHint(stepType, hintLevel = 1) {
        const mockStep = {
            operation: "100 + (-15)",
            result: "85",
            description: "Operaci√≥n de prueba"
        };
        
        const mockContext = {
            currentStep: 0,
            stepType: stepType,
            recentErrorPatterns: [],
            hintLevel: hintLevel,
            studentStruggle: 'low'
        };
        
        const strategy = this.selectHintStrategy(mockContext);
        return this.createContextualHint(0, { solution: { steps: [mockStep] } }, strategy, mockContext);
    }
}

// =====================================================
// FUNCIONES UTILITARIAS GLOBALES
// =====================================================

/**
 * Funci√≥n helper para crear hints personalizados
 * @param {string} message - Mensaje del hint
 * @param {string} icon - Icono a usar
 * @param {number} level - Nivel del hint
 * @returns {Object} Hint personalizado
 */
function createCustomHint(message, icon = "fas fa-lightbulb", level = 1) {
    return {
        level: level,
        type: "custom",
        strategy: "custom_hint",
        message: message,
        icon: icon,
        pedagogicalFocus: "custom_guidance"
    };
}

// =====================================================
// EXPORTACI√ìN Y COMPATIBILIDAD
// =====================================================

// Para uso en navegador (script tag)
if (typeof window !== 'undefined') {
    window.HintSystem = HintSystem;
    window.createCustomHint = createCustomHint;
}

// Para uso en Node.js (desarrollo/testing)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        HintSystem,
        createCustomHint
    };
}

console.log('üí° HintSystem cargado correctamente');

/**
 * RESUMEN DEL SISTEMA DE HINTS:
 * 
 * üß† INTELIGENCIA PEDAG√ìGICA:
 * - Hints adaptativos seg√∫n el error del estudiante
 * - Perfil del estudiante que evoluciona
 * - Estrategias diferenciadas por tipo de aprendizaje
 * - Biblioteca organizada por temas matem√°ticos
 * 
 * üéØ ENFOQUE CONSTRUCTIVISTA:
 * - Nivel 1: Orientaci√≥n conceptual
 * - Nivel 2: Gu√≠a procedimental
 * - Nivel 3: Ayuda expl√≠cita (√∫ltimo recurso)
 * - No da respuestas directas hasta el final
 * 
 * üìö BIBLIOTECA DE CONOCIMIENTO:
 * - Hints por tema matem√°tico espec√≠fico
 * - Patrones de error comunes identificados
 * - Estrategias de remediaci√≥n personalizadas
 * - Feedback constructivo siempre
 * 
 * ‚ö° CARACTER√çSTICAS AVANZADAS:
 * - An√°lisis de contexto del estudiante
 * - Adaptaci√≥n en tiempo real
 * - Sistema de perfilado de aprendizaje
 * - Debug y testing integrados
 * 
 * üé® INTEGRACI√ìN CON ECOSISTEMA:
 * - Consistente con patrones del Space Shooter
 * - Logging y debugging similar
 * - Gesti√≥n de estado estructurada
 * - Exportaci√≥n compatible
 */